Design Decisions
Modular Structure
I organized the code into logical modules to improve readability and maintainability. Each module handles a specific responsibility, making it easier to debug and extend.

Error Handling
I implemented comprehensive error handling to ensure the program can gracefully handle unexpected inputs or failures, improving user experience and reliability.

User Interface
I chose a simple and intuitive user interface to make the application accessible to users with varying technical backgrounds.

Data Storage
For data persistence, I selected a lightweight solution (such as JSON or SQLite) to balance performance and simplicity.

Challenges Faced
Ambiguous Requirements
Some requirements were open to interpretation, so I made assumptions based on typical use cases and clarified them in comments.

Edge Cases
Handling edge cases (such as invalid input or empty data sets) required additional validation logic to prevent crashes.

Time Constraints
Balancing thoroughness with efficiency was challenging, so I prioritized core functionality and documented areas for future improvement.